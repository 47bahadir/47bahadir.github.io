<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>获取程序的PID和模块基址 | BHD Tec</title>

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="/image/logo/bit.ico">
  <link rel="shortcut icon" type="image/x-icon" href="/image/logo/bit.ico">

  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

  <!-- 添加代码高亮样式 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
  <!-- 添加highlight.js库 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- 添加mermaid.js库 -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <link rel="stylesheet" href="/css/code.css">
  <link rel="stylesheet" href="/css/code-custom.css">
  <link rel="stylesheet" href="/css/code-languages.css">
  <link rel="stylesheet" href="/css/mermaid.css">

  <link rel="stylesheet" href="/css/vscode.css">
  <link rel="stylesheet" href="/css/post.css">
  <link rel="stylesheet" href="/css/tag.css">
  <link rel="stylesheet" href="/css/categories.css">
  <link rel="stylesheet" href="/css/archive.css">
  <link rel="stylesheet" href="/css/search.css">
  <link rel="stylesheet" href="/css/mobile.css">
  <link rel="stylesheet" href="/css/responsive.css">
  <link rel="stylesheet" href="/css/elements.css">
  <link rel="stylesheet" href="/css/statistics.css">

  <!-- 添加 JetBrains Mono 字体 -->  
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

  <!-- Add any custom head content here -->

  <script src="/js/explorer.js"></script>
  <script src="/js/code-copy.js"></script>
  <script src="/js/code-enhance.js"></script>
<meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    <div class="wrapper">
      <div class="mobile-menu-toggle">
        <i class="fas fa-bars"></i>
      </div>
      <header class="vs-header">
  <nav class="vs-nav">
    <div class="nav-left">
      <a href="/" class="nav-brand">
        <i class="fas fa-terminal"></i>
        BHD Tec
      </a>
    </div>
    
    <div class="nav-right">
      <a href="/" class="nav-item ">
        <i class="fas fa-home"></i>
        <span>首页</span>
      </a>
      <a href="/archives/" class="nav-item ">
        <i class="fas fa-archive"></i>
        <span>归档</span>
      </a>
      <a href="/categories/" class="nav-item ">
        <i class="fas fa-folder"></i>
        <span>分类</span>
      </a>
      <a href="/tags/" class="nav-item ">
        <i class="fas fa-tags"></i>
        <span>标签</span>
      </a>
      <a href="/search/" class="nav-item ">
        <i class="fas fa-search"></i>
        <span>搜索</span>
      </a>
      <a href="/about/" class="nav-item ">
        <i class="fas fa-info-circle"></i>
        <span>关于</span>
      </a>
    </div>
  </nav>
</header>

<script>
  function smoothScroll(event, target) {
    event.preventDefault();
    const targetId = target.substring(target.indexOf('#') + 1);
    const targetElement = document.getElementById(targetId);

    if (targetElement) {
      window.scrollTo({
        top: targetElement.offsetTop - 50, // 调整偏移量
        behavior: 'smooth'
      });
    } else {
      window.location.href = target;
    }
  }

  window.addEventListener('scroll', function() {
    const header = document.querySelector('.vs-header');
    const nav = document.querySelector('.vs-nav');
    const scrollPercent = (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
    
    nav.style.setProperty('--scroll-percent', `${scrollPercent}%`);
    
    if (window.scrollY > 0) {
      header.classList.add('scrolled');
    } else {
      header.classList.remove('scrolled');
    }
  });

  // 添加标签页切换动画
  document.querySelectorAll('.nav-item').forEach(item => {
    item.addEventListener('click', function(e) {
      const ripple = document.createElement('span');
      ripple.classList.add('nav-ripple');
      this.appendChild(ripple);
      
      const rect = this.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      ripple.style.left = `${x}px`;
      ripple.style.top = `${y}px`;
      
      setTimeout(() => ripple.remove(), 1000);
    });
  });
</script>


<div class="vscode-container">
  <!-- 左侧资源管理器 -->
  <div class="sidebar-explorer">
    <!-- TOC导航 -->
    <div class="explorer-section">
      <div class="section-header">
        <i class="fas fa-list"></i>
        <span>TABLE OF CONTENTS</span>
      </div>
      <div class="section-content">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F"><span class="toc-text">一，外部程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-PID%E8%8E%B7%E5%8F%96"><span class="toc-text">1.PID获取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Windows-API"><span class="toc-text">（1）Windows API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">（2）具体实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A8%A1%E5%9D%97%E5%9F%BA%E5%9D%80%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-text">2.模块基址的获取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Windows-API-1"><span class="toc-text">（1）Windows API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">（2）具体实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8CDLL%E6%B3%A8%E5%85%A5"><span class="toc-text">二，DLL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Windows-API-2"><span class="toc-text">（1）Windows API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">（2）具体实现</span></a></li></ol></li></ol>
      </div>
    </div>
    
    <!-- 同分类文章 -->
    
    <div class="explorer-section">
      <div class="section-header">
        <i class="fas fa-folder"></i>
        <span>CATEGORY POSTS</span>
      </div>
      <div class="section-content">
        
          <div class="file">
            <i class="fas fa-file-code"></i>
            <a href="/2025/04/11/post9/">函数Hook技术（Trampoline 蹦床）</a>
          </div>
        
          <div class="file">
            <i class="fas fa-file-code"></i>
            <a href="/2025/04/07/post8/">函数Hook技术（Detour 转向）</a>
          </div>
        
          <div class="file">
            <i class="fas fa-file-code"></i>
            <a href="/2025/04/01/post7/">游戏函数调用技术</a>
          </div>
        
      </div>
    </div>
    
    
    <!-- 标签列表 -->
    
    <div class="explorer-section">
      <div class="section-header">
        <i class="fas fa-tags"></i>
        <span>ARTICLE TAGS</span>
      </div>
      <div class="section-content">
        
          <div class="tag-item">
            <i class="fas fa-tag"></i>
            <a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>
            <span class="count">(9)</span>
          </div>
        
          <div class="tag-item">
            <i class="fas fa-tag"></i>
            <a href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a>
            <span class="count">(4)</span>
          </div>
        
          <div class="tag-item">
            <i class="fas fa-tag"></i>
            <a href="/tags/WINAPI/">WINAPI</a>
            <span class="count">(1)</span>
          </div>
        
      </div>
    </div>
    
  </div>

  <!-- 主要内容区域 -->
  <div class="editor-content">
    <div class="tab-bar">
      <div class="tab active">
        <i class="fas fa-file-alt"></i>
        <span>获取程序的PID和模块基址.md</span>
      </div>
    </div>
    
    <div class="content-area">
      <article class="post-content">
        <div class="post-header">
          <h1>获取程序的PID和模块基址</h1>
          <div class="post-meta">
            <span class="date">
              <i class="fas fa-calendar-alt"></i>
              2025-02-22
            </span>            
              <span class="categories">
                <i class="fas fa-folder"></i>
                <div class="categories-list">
                  <ul class="category-item-post-list"><li class="category-item-post-list-item"><a class="category-item-post-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a></li></ul>
                </div>
              </span>
            
            
              <span class="tags">
                <i class="fas fa-tags"></i>
                <div class="tags-list">
                  <ul class="tag-item-post-list" itemprop="keywords"><li class="tag-item-post-list-item"><a class="tag-item-post-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a></li><li class="tag-item-post-list-item"><a class="tag-item-post-list-link" href="/tags/WINAPI/" rel="tag">WINAPI</a></li><li class="tag-item-post-list-item"><a class="tag-item-post-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li></ul>
                </div>
              </span>
            
          </div>
        </div>
        
        <div class="post-body vscode-markdown">
          <p>PID是Process ID的缩写，每个正在运行的软件都会有各自的PID，类似于身份证号。只要进程被运行，操作系统会给每个运行的进程分配一个数字标识符。获得PID就可以对指定的进程进行内存修改，附加调试器等等操作。正常情况下打开Windows系统的任务管理器就能看到所有进程的PID信息：</p>
<img src="\image\post_image\post1\S1.png" style="zoom:67%;" />

<p>模块基址（Module Base Address）指的是被加载到内存中程序的内存空间起始地址。每打开一个进程操作系统除了分配PID之外还会给程序分配一段内存地址用来存放程序的代码和数据。这个内存地址的起点就是模块基址。PID是身份证号情况下模块基址相当于是家庭住址。</p>
<p>PID和模块基址对于逆向分析和内存分析来说至关重要，下面我会介绍外部程序（.exe程序）和DLL注入（内部注入）获取程序的PID和模块基址的具体方法。</p>
<h2 id="一，外部程序"><a href="#一，外部程序" class="headerlink" title="一，外部程序"></a>一，外部程序</h2><h3 id="1-PID获取"><a href="#1-PID获取" class="headerlink" title="1.PID获取"></a>1.PID获取</h3><h4 id="（1）Windows-API"><a href="#（1）Windows-API" class="headerlink" title="（1）Windows API"></a>（1）Windows API</h4><p>外部程序主要是通过调用 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Windows_API">Windows API</a> 的方式来获取其他程序的所有信息。要获取PID有几个API需要先了解分别是<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HANDLE <span class="hljs-title">CreateToolhelp32Snapshot</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD dwFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in] DWORD th32ProcessID</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>通过这个函数可以获取程序的快照信息，第二个参数为NULL时可以获取所有进程的快照信息。这里的快照包含了系统当前状态的各种信息，比如进程信息，线程信息，堆信息，模块信息等等。剩下两个API分别是<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/tlhelp32/nf-tlhelp32-process32first">Process32First</a> 函数和<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/tlhelp32/nf-tlhelp32-process32next">Process32Next</a> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">Process32First</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]      HANDLE           hSnapshot,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, out] LPPROCESSENTRY32 lppe</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><span class="hljs-function">BOOL <span class="hljs-title">Process32Next</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]  HANDLE           hSnapshot,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out] LPPROCESSENTRY32 lppe</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>这两个函数分别用来检索快照当中的第一个和下一个进程信息，可以用来<strong>遍历</strong>所有进程找到适合自己的进程然后获取所需要的信息。</p>
<h4 id="（2）具体实现"><a href="#（2）具体实现" class="headerlink" title="（2）具体实现"></a>（2）具体实现</h4><p>利用这两个API就可以很轻松的实现找到PID的操作，首先要先提供一个自己所需的程序名然后创建所有进程的快照。把这些快照中的程序名信息一个个拿出来跟我们提供的程序名进行对比，把对比成功的快照留下再从中获取我们需要的PID信息就行。下面是具体实现方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">DWORD <span class="hljs-title">mem::getProcId</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* procName)</span></span><br><span class="hljs-function"></span>&#123;<br>    DWORD retProcID = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化返回的进程ID</span><br><br>    <span class="hljs-comment">// 创建系统进程快照</span><br>    HANDLE hSnap = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">if</span> (hSnap != INVALID_HANDLE_VALUE)<br>    &#123;<br>        PROCESSENTRY32 procEntry;<br>        procEntry.dwSize = <span class="hljs-built_in">sizeof</span>(PROCESSENTRY32); <span class="hljs-comment">// 设置结构体大小</span><br><br>        <span class="hljs-comment">// 获取第一个进程信息</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Process32First</span>(hSnap, &amp;procEntry))<br>        &#123;<br>            <span class="hljs-keyword">do</span><br>            &#123;<br>                <span class="hljs-comment">// 比较进程名（不区分大小写）</span><br>                <span class="hljs-keyword">if</span> (!_wcsicmp(procName, procEntry.szExeFile))<br>                &#123;<br>                    retProcID = procEntry.th32ProcessID; <span class="hljs-comment">// 找到目标进程，保存ID</span><br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 结束循环</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32Next</span>(hSnap, &amp;procEntry)); <span class="hljs-comment">// 获取下一个进程信息</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 如果无法获取第一个进程，返回0</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">CloseHandle</span>(hSnap); <span class="hljs-comment">// 关闭快照句柄</span><br>    <span class="hljs-keyword">return</span> retProcID; <span class="hljs-comment">// 返回找到的进程ID，如果未找到则为0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-模块基址的获取"><a href="#2-模块基址的获取" class="headerlink" title="2.模块基址的获取"></a>2.模块基址的获取</h3><h4 id="（1）Windows-API-1"><a href="#（1）Windows-API-1" class="headerlink" title="（1）Windows API"></a>（1）Windows API</h4><p>模块基址的获取跟获取PID类似都是通过遍历系统快照来获取的，CreateToolhelp32Snapshot 函数的第二个参数中需要明确表明PID为了只针对单个进程遍历模块名。<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/tlhelp32/nf-tlhelp32-module32first">Module32First</a> 函数和 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/tlhelp32/nf-tlhelp32-module32next">Module32Next</a> 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">Module32First</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]      HANDLE          hSnapshot,</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, out] LPMODULEENTRY32 lpme</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><span class="hljs-function">BOOL <span class="hljs-title">Module32Next</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in]  HANDLE          hSnapshot,</span></span><br><span class="hljs-params"><span class="hljs-function">  [out] LPMODULEENTRY32 lpme</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>这两个是用来检索进程或线程关联的下一个模块的相关信息。比如在大部分软件当中一个可执行程序（.exe）程序会附带一堆dll模块，这两个函数可以遍历每一个模块直到找到自己所需要的。</p>
<h4 id="（2）具体实现-1"><a href="#（2）具体实现-1" class="headerlink" title="（2）具体实现"></a>（2）具体实现</h4><p>获取模块基址的步骤跟获取PID的步骤大差不差，都是通过快照遍历的方式来获取。获取模块基址之前要先获取PID作为CreateToolhelp32Snapshot 函数的第二个参数来传入。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">uintptr_t</span> <span class="hljs-title">mem::getModuleBase</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* procName, DWORD procID)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uintptr_t</span> retAddress = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始化返回的模块基址</span><br><br>    <span class="hljs-comment">// 创建指定进程的模块快照</span><br>    HANDLE hSnap = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, procID);<br><br>    <span class="hljs-keyword">if</span> (hSnap != INVALID_HANDLE_VALUE)<br>    &#123;<br>        MODULEENTRY32 modEntry;<br>        modEntry.dwSize = <span class="hljs-built_in">sizeof</span>(MODULEENTRY32); <span class="hljs-comment">// 设置结构体大小</span><br><br>        <span class="hljs-comment">// 获取第一个模块信息</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Module32First</span>(hSnap, &amp;modEntry))<br>        &#123;<br>            <span class="hljs-keyword">do</span><br>            &#123;<br>                <span class="hljs-comment">// 比较模块名（不区分大小写）</span><br>                <span class="hljs-keyword">if</span> (!_wcsicmp(procName, modEntry.szModule))<br>                &#123;<br>                    retAddress = (<span class="hljs-type">uintptr_t</span>)modEntry.modBaseAddr; <span class="hljs-comment">// 找到目标模块，保存基址</span><br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 结束循环</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Module32Next</span>(hSnap, &amp;modEntry)); <span class="hljs-comment">// 获取下一个模块信息</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">CloseHandle</span>(hSnap); <span class="hljs-comment">// 关闭快照句柄</span><br>    <span class="hljs-keyword">return</span> retAddress; <span class="hljs-comment">// 返回找到的模块基址，如果未找到则为0</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="二，DLL注入"><a href="#二，DLL注入" class="headerlink" title="二，DLL注入"></a>二，DLL注入</h2><p>DLL注入的全称为 Dynamic-Link Library Injection ，是一种将DLL模块强制加载到进程内存空间的技术。这个技术有多重用途比如安全监控，恶意软件攻击，调试程序等等。DLL注入说白了就是把自己写的代码强行写入到指定的程序让目标程序加载自己的代码。由于自身的代码已经在目标进程的内存空间当中了所以没有必要获取目标进程的PID了。</p>
<h3 id="（1）Windows-API-2"><a href="#（1）Windows-API-2" class="headerlink" title="（1）Windows API"></a>（1）Windows API</h3><p>在内部代码中获取基址变得极其简单，只需要调用Windows API中的<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea">GetModuleHandle</a> 函数，这个函数只有一个参数接受模块的名称（.dll 或 .exe 文件）。这个参数为NULL的话，返回的则是当前进程主模块的基地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HMODULE <span class="hljs-title">GetModuleHandleA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  [in, optional] LPCSTR lpModuleName</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure>

<p>可以发现这个函数的返回值并不是地址值而是句柄（HMODULE），在Windows内存管理体系中模块句柄直接等价于模块的基地址指针。在使用中直接把返回值强制转换成指针就行了。</p>
<h3 id="（2）具体实现-2"><a href="#（2）具体实现-2" class="headerlink" title="（2）具体实现"></a>（2）具体实现</h3><p>在实际使用中需要获取的基址为主要可执行文件的话（.exe）可以直接传NULL参即可。要是需要获取DLL模块的基址的话就需要传入模块名，传入模块名不加后缀默认按.dll来算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uintptr_t</span> baseAddress = (<span class="hljs-type">uintptr_t</span>)<span class="hljs-built_in">GetModuleHandle</span>(<span class="hljs-literal">NULL</span>);<br><span class="hljs-type">uintptr_t</span> baseAddress = (<span class="hljs-type">uintptr_t</span>)<span class="hljs-built_in">GetModuleHandle</span>(<span class="hljs-string">L&quot;xxx.dll&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>有需要补充的或者需要整改的可在评论区回复！</p>

        </div>
        
        <!-- 文章导航 -->
        <nav class="post-nav">
          
            <a class="prev" href="/2025/02/23/post2/">
              <i class="fas fa-chevron-left"></i>
              杀手5逆向分析（一）
            </a>
          
          
        </nav>
      </article>
    </div>
  </div>
</div>

    </div>
    <footer class="footer">
  <div class="status-bar">
    <div class="status-item">
      <i class="fas fa-code-branch"></i>
      master
    </div>
    <div class="status-item">
      <i class="fas fa-sync"></i>
      bahadir
    </div>
    <div class="status-item">
      <i class="fas fa-clock"></i>
      2025-08-21
    </div>
    <div class="status-item">
      Designed By&nbsp; <a href="https://github.com/47bahadir" target="_blank"> bahadir</a>
    </div>
    <div class="status-item github">
      <a href="https://github.com/47bahadir" target="_blank">
        <i class="fab fa-github"></i>
      </a>
    </div>
    <div class="status-item" id="site-runtime" style="margin-left: auto;">
      <i class="fas fa-heartbeat"></i>
      <span id="runtime-text">Site running for...</span>
    </div>
  </div>
</footer>

<script>
// 网站运行时间计算器
function updateSiteRuntime() {
  // 设置网站启动时间 (请根据实际情况修改这个日期)
  const startDate = new Date('2025-02-22 00:00:00'); // 修改为你的网站启动日期
  const now = new Date();
  const timeDiff = now - startDate;

  // 计算天数、小时、分钟、秒数
  const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
  const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);

  // 更新显示文本
  const runtimeText = `Site running for ${days} days ${hours} hours ${minutes} minutes ${seconds} seconds`;
  const runtimeElement = document.getElementById('runtime-text');
  if (runtimeElement) {
    runtimeElement.textContent = runtimeText;
  }
}

// 页面加载完成后开始计时
document.addEventListener('DOMContentLoaded', function() {
  updateSiteRuntime(); // 立即更新一次
  setInterval(updateSiteRuntime, 1000); // 每秒更新一次
});
</script>

    
    <!-- 全局配置 -->
    <script>
      window.HEXO_CONFIG = {
        language: "zh-CN",
        root: "/"
      };
      
      // 特定于搜索的配置
      window.VSC4T_SEARCH = {
        root: "/"
      };
    </script>
    
    <script src="//cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/highlight.js@11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <!-- 这里可以放置自定义脚本 -->
<script>
document.addEventListener('DOMContentLoaded', (event) => {
  // Apply smooth scroll to non-TOC anchor links
  document.querySelectorAll('a[href^="#"]:not(.toc-link)').forEach(anchor => {
    anchor.addEventListener('click', function (e) {
      e.preventDefault();
      // Check if querySelector is valid before using it
      try {
        const targetSelector = this.getAttribute('href');
        // Basic check for potentially invalid selectors (though not exhaustive)
        if (targetSelector && targetSelector.length > 1) { 
          const targetElement = document.querySelector(targetSelector);
          if (targetElement) {
            targetElement.scrollIntoView({
              behavior: 'smooth'
            });
          } else {
            console.warn('Smooth scroll target not found:', targetSelector);
          }
        } else {
           console.warn('Invalid href for smooth scroll:', targetSelector);
        }
      } catch (error) {
        console.error('Error during smooth scroll:', error, 'Selector:', this.getAttribute('href'));
        // Fallback or alternative behavior if needed
        // For example, try getElementById if it's just an ID
        const targetId = this.getAttribute('href').slice(1);
        try {
            const targetElementById = document.getElementById(decodeURIComponent(targetId));
            if (targetElementById) {
                targetElementById.scrollIntoView({ behavior: 'smooth' });
            }
        } catch (idError) {
             console.error('Fallback getElementById also failed:', idError);
        }
      }
    });
  });
});
</script>
<script src="/js/toc.js"></script>

<!-- Scripts -->
<script>
  // 将语言文件中的翻译传递给前端
  window.HEXO_CONFIG = {
    language: "zh-CN",
    search_placeholder: "输入关键词搜索...",
    search_no_results: "未找到相关结果",
    search_result: "Ergebnis",
    search_results: "搜索结果",
    search_results_found: "找到 undefined 个结果",
    search_in: "搜索范围",
    search_in_title: "标题",
    search_in_content: "内容",
    search_in_tags: "标签",
    search_in_categories: "分类",
    search_filters: "搜索过滤器",
    search_recent: "最近搜索",
    search_clear: "清除",
    search_loading: "加载中...",
    search_error: "加载搜索数据时出错"
  };
</script>



<!-- 添加所有需要的脚本 -->
<script src="/js/main.js"></script>
<script src="/js/search.js"></script>


    <script>
      // 移动端菜单切换
      $(document).ready(function() {
        $('.mobile-menu-toggle').click(function() {
          $('.sidebar-explorer').toggleClass('show');
        });
      });
    </script>
  </body>
</html>
