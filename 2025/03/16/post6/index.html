<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>射线检测函数的分析 | BHD Tec</title>

  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="/image/logo/bit.ico">
  <link rel="shortcut icon" type="image/x-icon" href="/image/logo/bit.ico">

  <!-- MathJax Support -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

  <!-- 添加代码高亮样式 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">
  <!-- 添加highlight.js库 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <!-- 添加mermaid.js库 -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <link rel="stylesheet" href="/css/code.css">
  <link rel="stylesheet" href="/css/code-custom.css">
  <link rel="stylesheet" href="/css/code-languages.css">
  <link rel="stylesheet" href="/css/mermaid.css">

  <link rel="stylesheet" href="/css/vscode.css">
  <link rel="stylesheet" href="/css/post.css">
  <link rel="stylesheet" href="/css/tag.css">
  <link rel="stylesheet" href="/css/categories.css">
  <link rel="stylesheet" href="/css/archive.css">
  <link rel="stylesheet" href="/css/search.css">
  <link rel="stylesheet" href="/css/math.css">
  <link rel="stylesheet" href="/css/mobile.css">
  <link rel="stylesheet" href="/css/responsive.css">
  <link rel="stylesheet" href="/css/elements.css">
  <link rel="stylesheet" href="/css/statistics.css">

  <!-- 添加 JetBrains Mono 字体 -->  
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

  <!-- Add any custom head content here -->

  <script src="/js/explorer.js"></script>
  <script src="/js/code-copy.js"></script>
  <script src="/js/code-enhance.js"></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>

  <body>
    <div class="wrapper">
      <div class="mobile-menu-toggle">
        <i class="fas fa-bars"></i>
      </div>
      <header class="vs-header">
  <nav class="vs-nav">
    <div class="nav-left">
      <a href="/" class="nav-brand">
        <i class="fas fa-terminal"></i>
        BHD Tec
      </a>
    </div>
    
    <div class="nav-right">
      <a href="/" class="nav-item ">
        <i class="fas fa-home"></i>
        <span>首页</span>
      </a>
      <a href="/archives/" class="nav-item ">
        <i class="fas fa-archive"></i>
        <span>归档</span>
      </a>
      <a href="/categories/" class="nav-item ">
        <i class="fas fa-folder"></i>
        <span>分类</span>
      </a>
      <a href="/tags/" class="nav-item ">
        <i class="fas fa-tags"></i>
        <span>标签</span>
      </a>
      <a href="/search/" class="nav-item ">
        <i class="fas fa-search"></i>
        <span>搜索</span>
      </a>
      <a href="/about/" class="nav-item ">
        <i class="fas fa-info-circle"></i>
        <span>关于</span>
      </a>
    </div>
  </nav>
</header>

<script>
  function smoothScroll(event, target) {
    event.preventDefault();
    const targetId = target.substring(target.indexOf('#') + 1);
    const targetElement = document.getElementById(targetId);

    if (targetElement) {
      window.scrollTo({
        top: targetElement.offsetTop - 50, // 调整偏移量
        behavior: 'smooth'
      });
    } else {
      window.location.href = target;
    }
  }

  window.addEventListener('scroll', function() {
    const header = document.querySelector('.vs-header');
    const nav = document.querySelector('.vs-nav');
    const scrollPercent = (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
    
    nav.style.setProperty('--scroll-percent', `${scrollPercent}%`);
    
    if (window.scrollY > 0) {
      header.classList.add('scrolled');
    } else {
      header.classList.remove('scrolled');
    }
  });

  // 添加标签页切换动画
  document.querySelectorAll('.nav-item').forEach(item => {
    item.addEventListener('click', function(e) {
      const ripple = document.createElement('span');
      ripple.classList.add('nav-ripple');
      this.appendChild(ripple);
      
      const rect = this.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      ripple.style.left = `${x}px`;
      ripple.style.top = `${y}px`;
      
      setTimeout(() => ripple.remove(), 1000);
    });
  });
</script>


<div class="vscode-container">
  <!-- 左侧资源管理器 -->
  <div class="sidebar-explorer">
    <!-- TOC导航 -->
    <div class="explorer-section">
      <div class="section-header">
        <i class="fas fa-list"></i>
        <span>TABLE OF CONTENTS</span>
      </div>
      <div class="section-content">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-text">一，射线检测的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">基本原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8CUnity%E5%BC%95%E6%93%8E%E5%BD%93%E4%B8%AD%E7%9A%84%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B"><span class="toc-text">二，Unity引擎当中的射线检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Ray%E5%B0%84%E7%BA%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.Ray射线的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Ray%E7%9A%84%E6%95%B0%E5%AD%A6%E8%A1%A8%E8%BE%BE"><span class="toc-text">2.Ray的数学表达</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">3.使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B0%84%E7%BA%BF%E7%A2%B0%E6%92%9E%E6%8D%95%E8%8E%B7%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">4.射线碰撞捕获的信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-LayerMask%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">5.LayerMask的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%9C%A8%E5%AE%9E%E9%99%85%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">6.在实际游戏中的引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%EF%BC%8CUnreal%E5%BC%95%E6%93%8E%E5%BD%93%E4%B8%AD%E7%9A%84%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B"><span class="toc-text">三，Unreal引擎当中的射线检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E8%93%9D%E5%9B%BE%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.通过蓝图实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87C-%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.通过C++方式实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E8%8E%B7%E5%8F%96%E7%8E%A9%E5%AE%B6%E8%A7%86%E8%A7%92"><span class="toc-text">（1）获取玩家视角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B0%84%E7%BA%BF%E8%B5%B7%E7%82%B9%E5%92%8C%E7%BB%88%E7%82%B9"><span class="toc-text">（2）射线起点和终点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E6%89%A7%E8%A1%8C%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B"><span class="toc-text">（3）执行射线检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%8E%B7%E5%8F%96%E9%98%9F%E4%BC%8D%E5%88%A4%E6%96%AD%E6%95%8C%E5%8F%8B"><span class="toc-text">（4）获取队伍判断敌友</span></a></li></ol></li></ol></li></ol>
      </div>
    </div>
    
    <!-- 同分类文章 -->
    
    <div class="explorer-section">
      <div class="section-header">
        <i class="fas fa-folder"></i>
        <span>CATEGORY POSTS</span>
      </div>
      <div class="section-content">
        
      </div>
    </div>
    
    
    <!-- 标签列表 -->
    
    <div class="explorer-section">
      <div class="section-header">
        <i class="fas fa-tags"></i>
        <span>ARTICLE TAGS</span>
      </div>
      <div class="section-content">
        
          <div class="tag-item">
            <i class="fas fa-tag"></i>
            <a href="/tags/%E6%8A%80%E6%9C%AF/">技术</a>
            <span class="count">(10)</span>
          </div>
        
          <div class="tag-item">
            <i class="fas fa-tag"></i>
            <a href="/tags/%E5%88%86%E6%9E%90/">分析</a>
            <span class="count">(1)</span>
          </div>
        
          <div class="tag-item">
            <i class="fas fa-tag"></i>
            <a href="/tags/%E5%87%BD%E6%95%B0/">函数</a>
            <span class="count">(4)</span>
          </div>
        
          <div class="tag-item">
            <i class="fas fa-tag"></i>
            <a href="/tags/API/">API</a>
            <span class="count">(4)</span>
          </div>
        
          <div class="tag-item">
            <i class="fas fa-tag"></i>
            <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</a>
            <span class="count">(1)</span>
          </div>
        
      </div>
    </div>
    
  </div>

  <!-- 主要内容区域 -->
  <div class="editor-content">
    <div class="tab-bar">
      <div class="tab active">
        <i class="fas fa-file-alt"></i>
        <span>射线检测函数的分析.md</span>
      </div>
    </div>
    
    <div class="content-area">
      <article class="post-content">
        <div class="post-header">
          <h1>射线检测函数的分析</h1>
          <div class="post-meta">
            <span class="date">
              <i class="fas fa-calendar-alt"></i>
              2025-03-16
            </span>            
              <span class="categories">
                <i class="fas fa-folder"></i>
                <div class="categories-list">
                  <ul class="category-item-post-list"><li class="category-item-post-list-item"><a class="category-item-post-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">代码分析</a></li></ul>
                </div>
              </span>
            
            
              <span class="tags">
                <i class="fas fa-tags"></i>
                <div class="tags-list">
                  <ul class="tag-item-post-list" itemprop="keywords"><li class="tag-item-post-list-item"><a class="tag-item-post-list-link" href="/tags/API/" rel="tag">API</a></li><li class="tag-item-post-list-item"><a class="tag-item-post-list-link" href="/tags/%E5%87%BD%E6%95%B0/" rel="tag">函数</a></li><li class="tag-item-post-list-item"><a class="tag-item-post-list-link" href="/tags/%E5%88%86%E6%9E%90/" rel="tag">分析</a></li><li class="tag-item-post-list-item"><a class="tag-item-post-list-link" href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag">技术</a></li><li class="tag-item-post-list-item"><a class="tag-item-post-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/" rel="tag">游戏引擎</a></li></ul>
                </div>
              </span>
            
          </div>
        </div>
        
        <div class="post-body vscode-markdown">
          <p>大部分FPS作弊程序都有一些必不可少的功能，包括自瞄，透视，自动扳机等。在研究这项技术时我发现这些技术的关键点在于调用游戏中的射线检测函数。下面我将介绍一些常见游戏引擎当中的射线检测功能，以及简单的讲解射线检测的实现原理。</p>
<hr>
<h1 id="一，射线检测的介绍"><a href="#一，射线检测的介绍" class="headerlink" title="一，射线检测的介绍"></a>一，射线检测的介绍</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>首先射线就是一条从一个点出发一直延长的线，跟现实中的激光一样但是在游戏中是无终点并且一般是不可见的。这条从一个点射出来的线碰到障碍物（开发者定义的障碍物）就会停止。在FPS游戏从始至终一直会使用这个射线来检测与游戏场景当中一些特定物体的交互情况。</p>
<p>在游戏中射线检测有很多的用途，比如玩家前面有一扇门，游戏开发者设定按下E键会开门。按照一般逻辑我们只有接近门然后视角对着门按E才能开门。那么怎么知道玩家是否在门的附近，而且是否面对着门呢？</p>
<p>当然就是用射线检测来实现这一功能。这个功能跟蝙蝠的超声波一样，从玩家的准星当中发出一条直线类似于超声波，等遇到前方的门或者其他物品之后这条射线就停止运动并返回它碰到的物品信息。在每一帧一直检测玩家的准星发射的射线碰到的物品以及距离，再根据相应的物品做出相应的操作。</p>
<img src="\image\post_image\post6\S1.png" alt="S1" style="zoom:67%;" />

<p>在一部分游戏中摄像机发射的Line Trace（射线检测）和枪械的弹道是不一样的，尤其是在一些第三人称射击游戏当中。以下是具体步骤：</p>
<ol>
<li>确定的起点和方向发射一条射线</li>
<li>计算射线与场景当中物体的相交点</li>
<li>返回这部分相交信息，比如是否相交，相交点（位置，距离，物体）等等</li>
</ol>
<hr>
<h1 id="二，Unity引擎当中的射线检测"><a href="#二，Unity引擎当中的射线检测" class="headerlink" title="二，Unity引擎当中的射线检测"></a>二，Unity引擎当中的射线检测</h1><h2 id="1-Ray射线的定义"><a href="#1-Ray射线的定义" class="headerlink" title="1.Ray射线的定义"></a>1.Ray射线的定义</h2><p>首先使用射线检测之前就必须要创建一条射线，Unity直接提供了这条射线的结构体。这是一条无穷的线，开始于origin点，朝向direction方向。在Unity的API当中提供了一个叫 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Ray-ctor.html">Ray</a> 的结构体，定义如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Ray</span>(<span class="hljs-params">Vector3 origin, Vector3 direction</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>origin是射线的起点位置，direction是射线的方向。</p>
<h2 id="2-Ray的数学表达"><a href="#2-Ray的数学表达" class="headerlink" title="2.Ray的数学表达"></a>2.Ray的数学表达</h2><p>Ray 用方程式表达形式如下：<br>$$<br>P(t)&#x3D;O+t⋅D<br>$$</p>
<ul>
<li><em>P</em>(<em>t</em>) 是射线上的点</li>
<li><em>O</em> 是射线起点（<code>ray.origin</code>）</li>
<li>D 是射线方向（<code>ray.direction</code>）</li>
<li>t 是参数（距离，t 大于等于 0）</li>
</ul>
<h2 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3.使用方法"></a>3.使用方法</h2><p>有常见的两种使用方法，一个是从玩家摄像机发射跟着鼠标的方向来检测的射线，还有一种是从玩家或者物体位置向前发射的射线：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 创建从摄像机到鼠标对准位置的射线</span><br>Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br><span class="hljs-comment">// 创建从物体位置向前的射线</span><br>Ray forwardRay = <span class="hljs-keyword">new</span> Ray(transform.position, transform.forward);<br></code></pre></td></tr></table></figure>

<h2 id="4-射线碰撞捕获的信息"><a href="#4-射线碰撞捕获的信息" class="headerlink" title="4.射线碰撞捕获的信息"></a>4.射线碰撞捕获的信息</h2><p>Unity会通过 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/RaycastHit.html">RaycastHit</a> 结构体来返回一堆所需要的信息，这个结构体包含了关于此射线碰撞的所有重要数据：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br>RaycastHit hit;<br><br><span class="hljs-keyword">if</span> (Physics.Raycast(ray, <span class="hljs-keyword">out</span> hit, <span class="hljs-number">100.0f</span>))<br>&#123;<br>    <span class="hljs-comment">// 现在可以访问 hit 中的所有信息</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><strong>collider</strong>  —— 射线击中的碰撞体</li>
<li><strong>transform</strong> —— 射线击中碰撞体所属于的 Transform 组件</li>
<li><strong>rigidbody</strong> —— 射线击中碰撞体关联的刚体（存在的情况下）</li>
<li><strong>point</strong> —— 射线与碰撞体相交的精准 Vec3 位置</li>
<li><strong>normal</strong> —— 射线碰撞处的表面法线（向量为单位）</li>
<li><strong>distance</strong> —— 射线起点到相交点的距离</li>
<li><strong>material</strong> —— 射线击中碰撞体的物理材质</li>
<li><strong>textureCoord（ textureCoord2 ）</strong> —— 射线碰撞点在物体纹理上的UV坐标（Vector2）</li>
<li><strong>triangleIndex</strong> —— 射线击中的三角形索引（针对网格碰撞体 int）</li>
<li><strong>barycentricCoordinate</strong> —— 射线碰撞点在击中三角形内的中心坐标点（Vector2）</li>
</ol>
<h2 id="5-LayerMask的概念"><a href="#5-LayerMask的概念" class="headerlink" title="5.LayerMask的概念"></a>5.LayerMask的概念</h2><p>Unity当中的每一个游戏对象都会被分配到特定的层（Layer），Unity本身就提供了一些默认的层，比如Default,Ignore Raycast,Water,UI等等。用户自定义的层有第8层到31层（User Layers 8 -31 ）。</p>
<p>LayerMask实际上是个32位整数，其中每一位对应一个层。比如某一位为1就代表包含在掩码中，反之为0表示在掩码外。以下是通过代码获取指定 LayerMask ：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c#">LayerMask playerEnemyMask = LayerMask.GetMask(<span class="hljs-string">&quot;Player&quot;</span>, <span class="hljs-string">&quot;Enemy&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>一般的用法也很简单通过 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Physics.Raycast.html">Physics.Raycast</a> 函数来实现，这个函数有多种用法可以通过查看官方文档来了解。这里只谈一些常用的用法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> LayerMask interactableLayers;		<span class="hljs-comment">//公开LayerMask类型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()			<span class="hljs-comment">//生命周期函数，每帧都会被调用</span></span><br>&#123;<br>    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);	<span class="hljs-comment">//创建射线，方向为鼠标位置</span><br>    RaycastHit hit;			<span class="hljs-comment">//用于存储射线击中物体的信息</span><br>    <span class="hljs-comment">// 只检测指定层的物体</span><br>    <span class="hljs-keyword">if</span> (Physics.Raycast(ray, <span class="hljs-keyword">out</span> hit, <span class="hljs-number">100.0f</span>, interactableLayers))<br>    &#123;<br>        Debug.Log(<span class="hljs-string">&quot;射线击中了指定层的物体: &quot;</span> + hit.collider.gameObject.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码解释：</p>
<ol>
<li>每一帧 ( 通过 <strong>Update()</strong> ) 执行以下操作</li>
<li>从当前鼠标指向的位置射出一条射线</li>
<li>使用 <strong>Physics.Raycast( )</strong> 检测射线是否击中指定物体</li>
<li>射线最远距离被限定为 100.0f</li>
<li>只检测 <strong>interactableLayers</strong> 指定层的物体</li>
<li>如果击中到了那就在控制台打印名称</li>
</ol>
<h2 id="6-在实际游戏中的引用"><a href="#6-在实际游戏中的引用" class="headerlink" title="6.在实际游戏中的引用"></a>6.在实际游戏中的引用</h2><p>下面展示在一般团队FPS当中的引用，实际情况肯定比这复杂多了。如何使用射线检测来识别准星指向的是敌人还是队友：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> UnityEngine;		<span class="hljs-comment">//导入Unity核心命名空间</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TargetDetector</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-comment">// 射线最大检测距离</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> detectionRange = <span class="hljs-number">100f</span>;<br>    <br>    <span class="hljs-comment">// 当前玩家的队伍ID</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> myTeamID = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 1=蓝队，2=红队</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()		<span class="hljs-comment">//生命周期函数，每帧都会被调用</span></span><br>    &#123;<br>        <span class="hljs-comment">// 从相机中心发射射线</span><br>        Ray ray = Camera.main.ViewportPointToRay(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.5f</span>, <span class="hljs-number">0</span>));<br>        RaycastHit hit;			<span class="hljs-comment">//收集击中信息</span><br>        <br>        <span class="hljs-comment">// 执行射线检测</span><br>        <span class="hljs-keyword">if</span> (Physics.Raycast(ray, <span class="hljs-keyword">out</span> hit, detectionRange))<br>        &#123;<br>            <span class="hljs-comment">// 尝试获取目标的队伍组件</span><br>            TeamMember targetTeam = hit.collider.GetComponent&lt;TeamMember&gt;();<br>            <br>            <span class="hljs-keyword">if</span> (targetTeam != <span class="hljs-literal">null</span>)<br>            &#123;<br>                <span class="hljs-comment">// 判断是敌人还是队友</span><br>                <span class="hljs-keyword">if</span> (targetTeam.teamID == myTeamID)<br>                &#123;<br>                    <span class="hljs-comment">// 是队友</span><br>                    Debug.Log(<span class="hljs-string">&quot;指向的是队友: &quot;</span> + targetTeam.playerName);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 是敌人</span><br>                    Debug.Log(<span class="hljs-string">&quot;指向的是敌人: &quot;</span> + targetTeam.playerName);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 简单的队伍成员组件</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TeamMember</span> : <span class="hljs-title">MonoBehaviour</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> teamID;  <span class="hljs-comment">// 1=蓝队，2=红队</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> playerName;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上只是简单的FPS游戏当中的调用，射线检测还有一大堆用途可以实现不同的功能。其他方法可以通过官方教程来探索，这里只介绍对于FPS当中的准星射线检测部分方便后续逆向分析用。</p>
<hr>
<h1 id="三，Unreal引擎当中的射线检测"><a href="#三，Unreal引擎当中的射线检测" class="headerlink" title="三，Unreal引擎当中的射线检测"></a>三，Unreal引擎当中的射线检测</h1><h2 id="1-通过蓝图实现"><a href="#1-通过蓝图实现" class="headerlink" title="1.通过蓝图实现"></a>1.通过蓝图实现</h2><p>UE引擎当中一般初学者使用的都是蓝图，在蓝图中可以搜到一些射线检测相关的API蓝图：</p>
<p><code>(前缀：Multi) + 射线形状 + [后缀：ForObjects|ByChannel|ByProfile]</code></p>
<p>加上前缀Multi代表射线可以穿透多个物体，没有这个前缀的话碰到第一个对象射线就失效了。后面的射线形状代表可以定义多种形状的射线，比如线形，球形，胶囊形等等。后缀就是按特定的方式来筛选分别是按类类型，通道类型和预设类型。</p>
<p>UE5官方指南有详细的蓝图链接教程可以点击<a target="_blank" rel="noopener" href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/using-a-single-line-trace-raycast-by-channel-in-unreal-engine?application_version=5.5">此教程</a>来研究是如何实现的，以下是成品模板：</p>
<img src="\image\post_image\post6\S2.png" alt="S2" style="zoom:67%;" />

<p>这里演示的 API 是 **Single Line Trace By Channel ** 只是对首个碰撞物体的检测（不会检测叠加的物体），命中物体之后会把物体的名称显示到屏幕上。</p>
<h2 id="2-通过C-方式实现"><a href="#2-通过C-方式实现" class="headerlink" title="2.通过C++方式实现"></a>2.通过C++方式实现</h2><p>以下是通过C++的方式来实现跟Unity相似的对于不同队伍的射线检测判断。</p>
<h3 id="（1）获取玩家视角"><a href="#（1）获取玩家视角" class="headerlink" title="（1）获取玩家视角"></a>（1）获取玩家视角</h3><p>通过C++实现其实跟Unity的概念上差不多，语法和实现方式稍有差别。首先要创建一个三维向量用来存储摄像机的位置，然后创建一个旋转器变量用来存储摄像机的旋转角度。之后通过函数获取摄像机的位置和旋转：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 获取玩家视角</span><br>FVector CameraLocation;<br>FRotator CameraRotation;<br><span class="hljs-built_in">GetActorEyesViewPoint</span>(CameraLocation, CameraRotation);<br></code></pre></td></tr></table></figure>

<h3 id="（2）射线起点和终点"><a href="#（2）射线起点和终点" class="headerlink" title="（2）射线起点和终点"></a>（2）射线起点和终点</h3><p>射线的起点就是摄像机的位置，终点就是先把摄像机旋转转换为Vector向量再乘以1000.0f（用户自定义）就得到了从摄像机朝向扩展1000个单位的向量了，这个加上摄像机开始位置得到了射线的终点坐标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 计算射线起点和终点</span><br>FVector TraceStart = CameraLocation;<br>FVector TraceEnd = CameraLocation + (CameraRotation.<span class="hljs-built_in">Vector</span>() * <span class="hljs-number">1000.0f</span>);<br></code></pre></td></tr></table></figure>

<h3 id="（3）执行射线检测"><a href="#（3）执行射线检测" class="headerlink" title="（3）执行射线检测"></a>（3）执行射线检测</h3><p>先创建 <strong>FHitResult</strong> 结构体来存储射线检测结果（跟RaycastHit差不多），然后通过 <strong>LineTraceSingleByChannel</strong> 执行单次射线检测返回首个碰撞结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 执行射线检测</span><br><span class="hljs-type">bool</span> bHit = <span class="hljs-built_in">GetWorld</span>()-&gt;<span class="hljs-built_in">LineTraceSingleByChannel</span>(		<span class="hljs-comment">//bHit返回是否击中了物体</span><br>    HitResult,			<span class="hljs-comment">//存储射线检测的结果</span><br>    TraceStart,			<span class="hljs-comment">//射线的起点</span><br>    TraceEnd,			<span class="hljs-comment">//射线的终点</span><br>    ECC_Visibility,	 	<span class="hljs-comment">//碰撞通道，这里使用的是可见性通道</span><br>    <span class="hljs-built_in">FCollisionQueryParams</span>()		<span class="hljs-comment">//碰撞查询参数，默认值</span><br>);<br></code></pre></td></tr></table></figure>

<p>再通过判断来处理 bHit 的检测结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 处理检测结果</span><br><span class="hljs-keyword">if</span> (bHit)		<span class="hljs-comment">//是否击中了物体</span><br>&#123;<br>    AActor* HitActor = HitResult.<span class="hljs-built_in">GetActor</span>();		<span class="hljs-comment">//获取被射线击中的对象（Actor）</span><br>    <span class="hljs-keyword">if</span> (HitActor)	<span class="hljs-comment">//确保获取到了对象</span><br>    &#123;<br></code></pre></td></tr></table></figure>

<h3 id="（4）获取队伍判断敌友"><a href="#（4）获取队伍判断敌友" class="headerlink" title="（4）获取队伍判断敌友"></a>（4）获取队伍判断敌友</h3><p>在击中的对象身上找有没有 <strong>UTeamComponent</strong> 类型的组件，如果存在再继续判断是敌人还是队友：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 获取目标的队伍组件</span><br>UTeamComponent* TeamComponent = HitActor-&gt;<span class="hljs-built_in">FindComponentByClass</span>&lt;UTeamComponent&gt;();<br><span class="hljs-keyword">if</span> (TeamComponent)		<span class="hljs-comment">//检查是否成功找到了队伍组件</span><br>&#123;<br></code></pre></td></tr></table></figure>

<p>再通过击中玩家的队伍ID来判断是敌是友，之后把调试信息打印出来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++">int32 TargetTeamID = TeamComponent-&gt;TeamID;		<span class="hljs-comment">//访问队伍组件中的 TeamID 属性</span><br>int32 MyTeamID = <span class="hljs-number">1</span>; <span class="hljs-comment">// 假设玩家队伍ID为1</span><br><br><span class="hljs-keyword">if</span> (TargetTeamID == MyTeamID)		<span class="hljs-comment">//比较队伍 ID 判断是敌是友</span><br>&#123;<br>    <span class="hljs-comment">// 是队友</span><br>    GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">2.0f</span>, FColor::Green, <br>        FString::<span class="hljs-built_in">Printf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;队友: %s&quot;</span>), *HitActor-&gt;<span class="hljs-built_in">GetName</span>()));<span class="hljs-comment">//在屏幕上显示调试信息</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// 是敌人</span><br>    GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">2.0f</span>, FColor::Red, <br>        FString::<span class="hljs-built_in">Printf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;敌人: %s&quot;</span>), *HitActor-&gt;<span class="hljs-built_in">GetName</span>()));<span class="hljs-comment">//在屏幕上显示调试信息</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么整体工作流程就是先获取玩家摄像机的位置和朝向，再计算射线的起点和终点，之后执行射线检测检查是否击中了物体。如果击中了物体获取被击中的对象信息，从对象信息中找队伍组件，如果有队伍组件的话就比较队伍ID判断是敌是友，最后在屏幕上显示敌友信息。以下是简单但功能完整的UE射线检测代码（实际游戏比这复杂）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在头文件中声明</span><br><span class="hljs-built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="hljs-string">&quot;Detection&quot;</span>)<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PerformLineTrace</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 在 CPP 文件中实现</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AMyCharacter::PerformLineTrace</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取玩家视角</span><br>    FVector CameraLocation;<br>    FRotator CameraRotation;<br>    <span class="hljs-built_in">GetActorEyesViewPoint</span>(CameraLocation, CameraRotation);<br>    <br>    <span class="hljs-comment">// 计算射线起点和终点</span><br>    FVector TraceStart = CameraLocation;<br>    FVector TraceEnd = CameraLocation + (CameraRotation.<span class="hljs-built_in">Vector</span>() * <span class="hljs-number">1000.0f</span>);<br>    <br>    <span class="hljs-comment">// 射线检测结果</span><br>    FHitResult HitResult;<br>    <br>    <span class="hljs-comment">// 执行射线检测</span><br>    <span class="hljs-type">bool</span> bHit = <span class="hljs-built_in">GetWorld</span>()-&gt;<span class="hljs-built_in">LineTraceSingleByChannel</span>(<br>        HitResult,<br>        TraceStart,<br>        TraceEnd,<br>        ECC_Visibility,<br>        <span class="hljs-built_in">FCollisionQueryParams</span>()<br>    );<br>    <br>    <span class="hljs-comment">// 处理检测结果</span><br>    <span class="hljs-keyword">if</span> (bHit)<br>    &#123;<br>        AActor* HitActor = HitResult.<span class="hljs-built_in">GetActor</span>();<br>        <span class="hljs-keyword">if</span> (HitActor)<br>        &#123;<br>            <span class="hljs-comment">// 获取目标的队伍组件</span><br>            UTeamComponent* TeamComponent = HitActor-&gt;<span class="hljs-built_in">FindComponentByClass</span>&lt;UTeamComponent&gt;();<br>            <span class="hljs-keyword">if</span> (TeamComponent)<br>            &#123;<br>                int32 TargetTeamID = TeamComponent-&gt;TeamID;<br>                int32 MyTeamID = <span class="hljs-number">1</span>; <span class="hljs-comment">// 假设玩家队伍ID为1</span><br>                <br>                <span class="hljs-keyword">if</span> (TargetTeamID == MyTeamID)<br>                &#123;<br>                    <span class="hljs-comment">// 是队友</span><br>                    GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">2.0f</span>, FColor::Green, <br>                        FString::<span class="hljs-built_in">Printf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;队友: %s&quot;</span>), *HitActor-&gt;<span class="hljs-built_in">GetName</span>()));<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">// 是敌人</span><br>                    GEngine-&gt;<span class="hljs-built_in">AddOnScreenDebugMessage</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">2.0f</span>, FColor::Red, <br>                        FString::<span class="hljs-built_in">Printf</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;敌人: %s&quot;</span>), *HitActor-&gt;<span class="hljs-built_in">GetName</span>()));<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上就是两大游戏引擎的射线检测功能分析，其他游戏引擎跟这两个引擎的检测方式大差不差，在逆向分析当中可以当作参考点来学习。文章当中有需要更改的部分请在评论区指出，谢谢观看！</p>

        </div>
        
        <!-- 文章导航 -->
        <nav class="post-nav">
          
            <a class="prev" href="/2025/04/01/post7/">
              <i class="fas fa-chevron-left"></i>
              游戏函数调用技术
            </a>
          
          
            <a class="next" href="/2025/03/08/post5/">
              杀手5逆向分析（四）
              <i class="fas fa-chevron-right"></i>
            </a>
          
        </nav>
      </article>
    </div>
  </div>
</div>

    </div>
    <footer class="footer">
  <div class="status-bar">
    <div class="status-item">
      <i class="fas fa-code-branch"></i>
      master
    </div>
    <div class="status-item">
      <i class="fas fa-sync"></i>
      bahadir
    </div>
    <div class="status-item">
      <i class="fas fa-clock"></i>
      2025-08-22
    </div>
    <div class="status-item">
      Designed By&nbsp; <a href="https://github.com/47bahadir" target="_blank"> bahadir</a>
    </div>
    <div class="status-item github">
      <a href="https://github.com/47bahadir" target="_blank">
        <i class="fab fa-github"></i>
      </a>
    </div>
    <div class="status-item" id="site-runtime" style="margin-left: auto;">
      <i class="fas fa-heartbeat"></i>
      <span id="runtime-text">Site running for...</span>
    </div>
  </div>
</footer>

<script>
// 网站运行时间计算器
function updateSiteRuntime() {
  // 设置网站启动时间 (请根据实际情况修改这个日期)
  const startDate = new Date('2025-02-22 00:00:00'); // 修改为你的网站启动日期
  const now = new Date();
  const timeDiff = now - startDate;

  // 计算天数、小时、分钟、秒数
  const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
  const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);

  // 更新显示文本
  const runtimeText = `Site running for ${days} days ${hours} hours ${minutes} minutes ${seconds} seconds`;
  const runtimeElement = document.getElementById('runtime-text');
  if (runtimeElement) {
    runtimeElement.textContent = runtimeText;
  }
}

// 页面加载完成后开始计时
document.addEventListener('DOMContentLoaded', function() {
  updateSiteRuntime(); // 立即更新一次
  setInterval(updateSiteRuntime, 1000); // 每秒更新一次
});
</script>

    
    <!-- 全局配置 -->
    <script>
      window.HEXO_CONFIG = {
        language: "zh-CN",
        root: "/"
      };
      
      // 特定于搜索的配置
      window.VSC4T_SEARCH = {
        root: "/"
      };
    </script>
    
    <script src="//cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/highlight.js@11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <!-- 这里可以放置自定义脚本 -->
<script>
document.addEventListener('DOMContentLoaded', (event) => {
  // Apply smooth scroll to non-TOC anchor links
  document.querySelectorAll('a[href^="#"]:not(.toc-link)').forEach(anchor => {
    anchor.addEventListener('click', function (e) {
      e.preventDefault();
      // Check if querySelector is valid before using it
      try {
        const targetSelector = this.getAttribute('href');
        // Basic check for potentially invalid selectors (though not exhaustive)
        if (targetSelector && targetSelector.length > 1) { 
          const targetElement = document.querySelector(targetSelector);
          if (targetElement) {
            targetElement.scrollIntoView({
              behavior: 'smooth'
            });
          } else {
            console.warn('Smooth scroll target not found:', targetSelector);
          }
        } else {
           console.warn('Invalid href for smooth scroll:', targetSelector);
        }
      } catch (error) {
        console.error('Error during smooth scroll:', error, 'Selector:', this.getAttribute('href'));
        // Fallback or alternative behavior if needed
        // For example, try getElementById if it's just an ID
        const targetId = this.getAttribute('href').slice(1);
        try {
            const targetElementById = document.getElementById(decodeURIComponent(targetId));
            if (targetElementById) {
                targetElementById.scrollIntoView({ behavior: 'smooth' });
            }
        } catch (idError) {
             console.error('Fallback getElementById also failed:', idError);
        }
      }
    });
  });
});
</script>
<script src="/js/toc.js"></script>

<!-- Scripts -->
<script>
  // 将语言文件中的翻译传递给前端
  window.HEXO_CONFIG = {
    language: "zh-CN",
    search_placeholder: "输入关键词搜索...",
    search_no_results: "未找到相关结果",
    search_result: "نتيجة",
    search_results: "搜索结果",
    search_results_found: "找到 undefined 个结果",
    search_in: "搜索范围",
    search_in_title: "标题",
    search_in_content: "内容",
    search_in_tags: "标签",
    search_in_categories: "分类",
    search_filters: "搜索过滤器",
    search_recent: "最近搜索",
    search_clear: "清除",
    search_loading: "加载中...",
    search_error: "加载搜索数据时出错"
  };
</script>



<!-- 添加所有需要的脚本 -->
<script src="/js/main.js"></script>
<script src="/js/search.js"></script>


    <script>
      // 移动端菜单切换
      $(document).ready(function() {
        $('.mobile-menu-toggle').click(function() {
          $('.sidebar-explorer').toggleClass('show');
        });
      });
    </script>
  </body>
</html>
